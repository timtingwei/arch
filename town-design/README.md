# 10.19
## 1, 增加映射对象TypeMapping类中, 结点对路径的映射[X]
## 2, 分离交通时间计算方法 和 扩展或压缩时间区间的方法[X]

# 10.20
## 1, 增加起床时间点选择方法[X]
## 2, 增加整合从00:00开始, 事件和交通对应的时段地点(或者路径)的准确序列[-]
## 3, 对导入的数据进行查错[X]
### 修改'：'成':'
### 啃老族, 扫地工人, 农村自建房 改成 农田自建房
### 渔民进鱼苗缺个时间区间(20)
### 21-厂长在工厂办公区间分割符号有问题
### 中心学校校长地点不全


# 10.21
## 1, 分离出一些之前直接给值的接口: 职业总人数, 职业分配比, 建筑类型对应的地块数量[X]
## 2, 根据准确序列为每个对象绘制行动路径, 修改10.20策略, 一天从起床吃饭开始记, 直到第二天完成睡觉
## 3, 增加交通方式的选择, 1km以内走路, 1km以上选择用最快交通工具[X]

# 10.22
## 1, 将路网和宽度啊遍历运算出来的路径, 设计存储结构, 完善查交通路径的接口[X]
## 2, 城市人口流动动画绘制[X]
### 1, 按帧数画点的框架[X]
### 2, 根据child.place得到区块点表(placeptlst)[X]
### 3, 根据child.trans_path得到道路多段线(roadcurvelst)[X]
### 4, 增添evaluateCurveByLength()方法: 组合line成polyline, 根据距离得到线上对应点[X]


# 10.24
## 1, 构造Block类, Blocks类[X]
## 2, 统计一天中某区块一天中使用的总人流量[X]
## 3, 统计一天中某区块一天中最大的同时使用人数[X]
### 这个问题等价于该地块一天中, 不同时段人数分布, 要取得最大的同时使用人数, 只是将时段切割的很小[X]
## 4, 统计一天各地块总共花费的时长[X]
## 5, 根据区块人数分布, 增添控制建筑密度, 容积率, 建筑数量, 得到建筑面积, 建筑高度[X]


# 10.25
## 1, 增添一个判断, 区块控制容积率, 建筑密度, 建筑数量的同时, 设置最小建筑高度, 最小建筑面积, 用最大建筑数量修改输入[X]
## 2, 修复两个地点的关联性和两个事件的关联性bug[X]
## 3, 重新定义建筑类型块, 区块和实际地块的层级结构和关系


# 10.26

## 1, 修改实际区块容积率, 覆盖率, 建筑面积, 高度, 栋数的计算

# 10.27
## 1, 构思地块属性分配方案

# 10.29
## 1. 地块属性和地块上建筑分配包(可作为人脑介入的ui)
## 2. 补写让基因条得到的使用面积更真实合理的机制

# 10.30
## 1. 为地块分配机制的判断, 添加哪些是机制运行但有误, 哪些是机制不运行缺少参数[X]
## 2. 分清楚返回的结果中, 哪些是全局变量, 哪些是局部产生的变量[X]
## 3. 增加将输入None值, 填充成和其他几个元素长度相等, 数据为0的数列[X]
## 4. 增加三元和四元计算的数据类型申明, 排除整数输入面积的除法错误[X]

# 10.31
## 1. 抽象, 剩余建筑面积机制的抽象[X]
## 2. 修改, 二元+建筑面积的输入, 得到容积率为0.0问题: 总建筑面积在同一个运算中, 是否再被运算先做个标记[X]
## 3. 增加, 将对输入的面积比例转换成0~1之间的数(实际的转换不放在前面, 放在中间局部)[X]
## 4. 完成gh中的版本以及处理绘图[X]
## 5. 为fillParamsList()添加 无输入或者空列表(适应gh的输入)的情况判断[-]

# 11.1(0.2)
## 1. GH绘图部分栋数的数据结构修改[X]
## 2. 修改, 将已有建筑占地面积算地块面积是否满足条件, 作为覆盖率的条件; 已有建筑面积作为算容积率的一个变量, 考虑进来[X]
## 3. 修改, 将打印提示的名词替换成gh中变量输入的名字[X]

# 面积转换宽深机制
# 11.1
## 1. 增加, 根据面积得到新的值域范围进行计算方法

# 地块属性分配机制
# 11.2
## 1. 根据老师要求, 把地块分配的情况拆开成11个机制, 让老师删减

## 判断机制后的限制处理: 可以拉到某个变量的最大值, 然后保持不变
----
# 开始参与几何部分的内容
## 向量法阴阳角判断问题
## 向量法矩形之间最短路问题

# 11.3
## 思路上, 遍历出向量法矩形之间的最短路的选择情况
## 确定矩形上位点不能直接相连时, 最多四种选择的运算

# 11.4
## 最短路径问题前的构造
### 矩形构造[X]
### 两个矩形关系构造[X]
#### 角点之间的可见性
#### 两个矩形是否平行
#### 两个矩形间距是属于哪种类型
#### 矩形之间的间距
### 向量构造[X]
### 位点构造[X]

## 阴阳角问题
### 点构造[X]
### 向量构造[X]
### 多边形构造[X]

# 11.5
## 实现两个矩形间的最短路径思路框架[X]

# 11.6
## 1. 实现矩形的角点的向量象限的构造的方法[X]
## 2. 增加向量是否在象限中的方法[X]-hxj提供
## 3. 增加两条射线(pt+vec)求交点的方法[X]-hxj提供
## 4. 增加根据两个可见象限, 两个夹b向量, 判断最短路径向量方法[X]-hxj提供
## 5. 增加矩形计算角点之间可见性的方法, getCornerVisiableAndPath()[X]
## 6. 修改Polyline构造, 由向量构造(向量作为通用的运算)[X]
## 7. 增加向量的点积, 叉积, 向量长度, 反向量[X]
## 8. 增加向量长度属性, 在构造Polyline实例时候的长度属性传入, Rectangle的veclengthlst属性[X]
## 9. Vector类reverse方法重写, 测试对象赋值(不太行, 重载ok)[X]
## 10. 实现根据实例属性找到最短路的方法findShortestPath()[X]

# 11.7
## 1. 抽象最短路和矩形关系类中相同的代码成方法[X]
## 2. 添加RectangleCornerPoint类和构造, RectangleEdgePoint类和构造[X]
## 3. 实现Polyline类的addPolyline()方法[X] -hzp提供
## 4. 增加向量的unit(), amplify()工具方法[X] -xyx提供
## 5. 优化构造, 存储并调用两个矩形角点之间的向量, 替换(initVecBetweenPts)[X]
## 6. 补写两个向量平行Vector::isVectorParallel()和两个矩形平行RectangleRelation::isParallel()方法[X]
## 7. 优化: 省略掉一些initVecBetweenPts()的计算[X]
## 8. 优化: 最短路径问题, 在边上选择点时, 可能存在角点的问题[X]
## 9. 优化: initVecBetweenPts()修改成VectorTwoPts类构造[X]
## 10. 测试
### 10.1: 交换类定义顺序, 两个语法错误[X]
### 10.2: 角点和边点veclst属性, 通过父类构造函数初始化[X]
### 10.3: relation实例中, phrase大量为None, isFolde()大量返回0(不夹)[X]-hxj修改[X]
### 10.4: rayrayIntersect()方法中, 除数为0

# 11.8
## 1.测试:
### 1.1 rayrayIntersect()方法中, 除数为0[]->在minAngleVector方法中, 最小向量bug[X]-hxj提供
### 1.2 修改角点间路径索引bug, Polyline路径长度调用属性而不是函数[X]
### 1.3 测试非正交情况[X]
### ----初步编译, 逻辑通过----
### 1.3 测试最短路算法的在边点的正确性[]
### 1.4 测试:可见点之间的最短路径relation.cornerShortestPath_dict[X]
### 1.5 bug: 边点到角点的路径dict出错[X]
#### bug1: 边上点到该边尾的向量的出错[]->addPolylines()方法改变了实例对象属性...
#### bug2: vec.reverse()方法可能也存在该问题[-]
##### 不存在, 考虑重构
#### bug3: getRectangleEdgeToCornerPath()向量方向对应出错[X]
## 2. 设计一个可用于格式化打印属性的类, 所有对象继承这个类[X]-> 优化成能展开结构[-]
### ----可放进gh测试----
### 3. gh测试
#### 3.1 最短路在角点时, 路径的选择
##### bug1: getRectangleCornerPath()向量方向对应出错[X]
#### 3.2 边上可见点的判断机制重写,(思路错误)[X]
##### 重构: 可见点路径选择计算层级重构[X]
## 3. 设计一个用于将底层架构的对象属性转换成gh数据的类[X]

# 11.9
## 1. 角点和边点的四个位点编号存成属性调用[X]

# 11.13
## 1. 建立在底层架构上, 组织排建筑结构算法[]
## 2. 构思建筑作为智能体的排房方法[]
## 3. 修改最短路算法, 选择点为角点时的poly是list问题[X]
## 4. 建筑间距和建筑间距类型属性[X]-hxj提供

# 11.14
## 1. 增加沿着多段线布置矩形方法[]
## 2. 增加Polyline类的几个子类, 建筑Arch类(Rectangle), 地块边界Edge类(Polyline), 道路Road类(Polyline), 存在继承关系[]
## 3. 测试: gh矩形转换成构造数据类型[]-xyx提供


# 11.15
## 1. 沿着边界排建筑debug：
### 1.1. debug: 'Edge' object has no attribute 'veclengthlst': Rectangle类中的一些方法和属性, 放在Polyline类中, Rectangle使用超类继承[X]
### 1.2 debug: arrange文件返回的三变量都是空列表: computeArchPosition方法中, 不在线段上的长度才重新滞空, 少两个not[X]
### 1.3 debug: 添加逆时针旋转90度的向量方法Vector::rotateVertical()[X]
### 1.4 测试ReverseVector类和类方法Vector::reverse()的区别, 是否会改变实例对象[X]
### 1.5 debug: fillArchWithRectangle方法, 用超类构造函数填充[X]
## 2. 增加:将gh的polyline转化成构造的polyline实例的静态方法[X]

----
stone在这里说要暂停技术, 那我就自己并行着做了.

# 11.16
## 1. debug: 修改polyline的构造veclst和startpt的顺序, 做到几个继承类和调用的统一[X]
## 2. 思路错误: 沿着边界排建筑的改变长度的同时间距改变的原因[X]-> 应该记录start_length

# 11.17
## 1. 将面积转宽深机制与沿着边界排房子结合起来[X]
## 2. debug: 修改hxj测试最短路径时, 选择点为角点时, 路径不存在列表中的问题[X]
## 3. 增加: 沿着边界排建筑的GhDisplay中的方法(可直接在ghPython中导入), GHDisplay::displayArrangeArchWithEdgePoly()[X]

----
整合现有的算法:
现状人口建筑类型描述模型
地块建筑属性分配
主干道路割地块

两个矩形间最短路径
两个矩形间距, 分类
沿着道路边界排建筑
# 11.18
## 1. debug: 修改间距的定义是, 和上一位点在edge上的距离, 而不是下一个合适线段的开始端点[X]
## 2. debug: 增加转角阴阳角时的避让[-]
## 3. 测试: 将GHDisplay::convertRecs拆成两个函数[X]

## 4. 讨论排房子方案
### 1.分计算层级
### 2.分出对象层级
#### 1.地块
#### 2.区块
#### 3.建筑
#### 4.区块间道路
#### 4.地块边缘
### 3. 构思
#### a. 构造类对象
#### b. 对象属性
#### c. 关系算法

# 11.19
## 1. 地块属性分配算法先归成Block类[]
## 2. debug: 增加转角阴阳角时的避让[-]

# 11.20
## 1. 构思讨论在排建筑驱动问题+剩余几何问题
### 1. 建筑组团组合方式
### 2. 层级类构造[X]
### 3. 建筑转换成矩形刚体
### 4. 刚体间距(碰撞)
### 5. 地块划分成区块[类属性描述]
### 6. 地块建筑分配结构组织

# 11.21
## 层级类构造[]
## 建筑转换成矩形刚体[]
## 刚体根据间距生成刚体[]
## 建筑组团组合方式[]
